/* automatically generated by rust-bindgen 0.59.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 0;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 0;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_64_BIT_INO_T: &'static [u8; 9usize] = b"$INODE64\0";
pub const __DARWIN_SUF_1050: &'static [u8; 6usize] = b"$1050\0";
pub const __DARWIN_SUF_EXTSN: &'static [u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = u128;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__mbstate8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>()))._mbstateL as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__darwin_pthread_handler_rec>())).__next as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_attr_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_cond_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_condattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutex_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_mutexattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_once_t>())).__opaque as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlock_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__sig as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_rwlockattr_t>())).__opaque as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__sig as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_opaque_pthread_t>())).__cleanup_stack as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_opaque_pthread_t>())).__opaque as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[doc = " A pointer to a sized fragment of a string, not necessarily null-terminated."]
#[doc = " Does not own the underlying string. This is equivalent to llvm::StringRef."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirStringRef {
    #[doc = "< Pointer to the first symbol."]
    pub data: *const ::std::os::raw::c_char,
    #[doc = "< Length of the fragment."]
    pub length: size_t,
}
#[test]
fn bindgen_test_layout_MlirStringRef() {
    assert_eq!(
        ::std::mem::size_of::<MlirStringRef>(),
        16usize,
        concat!("Size of: ", stringify!(MlirStringRef))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirStringRef>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirStringRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirStringRef>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirStringRef),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirStringRef>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirStringRef),
            "::",
            stringify!(length)
        )
    );
}
extern "C" {
    #[doc = " Constructs a string reference from a null-terminated C string. Prefer"]
    #[doc = " mlirStringRefCreate if the length of the string is known."]
    pub fn mlirStringRefCreateFromCString(str_: *const ::std::os::raw::c_char) -> MlirStringRef;
}
#[doc = " A callback for returning string references."]
#[doc = ""]
#[doc = " This function is called back by the functions that need to return a"]
#[doc = " reference to the portion of the string with the following arguments:"]
#[doc = "  - an MlirStringRef representing the current portion of the string"]
#[doc = "  - a pointer to user data forwarded from the printing call."]
pub type MlirStringCallback = ::std::option::Option<
    unsafe extern "C" fn(arg1: MlirStringRef, arg2: *mut ::std::os::raw::c_void),
>;
#[doc = " A logical result value, essentially a boolean with named states. LLVM"]
#[doc = " convention for using boolean values to designate success or failure of an"]
#[doc = " operation is a moving target, so MLIR opted for an explicit class."]
#[doc = " Instances of MlirLogicalResult must only be inspected using the associated"]
#[doc = " functions."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLogicalResult {
    pub value: i8,
}
#[test]
fn bindgen_test_layout_MlirLogicalResult() {
    assert_eq!(
        ::std::mem::size_of::<MlirLogicalResult>(),
        1usize,
        concat!("Size of: ", stringify!(MlirLogicalResult))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirLogicalResult>(),
        1usize,
        concat!("Alignment of ", stringify!(MlirLogicalResult))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirLogicalResult>())).value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirLogicalResult),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirContext {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirContext() {
    assert_eq!(
        ::std::mem::size_of::<MlirContext>(),
        8usize,
        concat!("Size of: ", stringify!(MlirContext))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirContext>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirContext>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirContext),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialect {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirDialect() {
    assert_eq!(
        ::std::mem::size_of::<MlirDialect>(),
        8usize,
        concat!("Size of: ", stringify!(MlirDialect))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirDialect>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirDialect))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirDialect>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirDialect),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOperation {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirOperation() {
    assert_eq!(
        ::std::mem::size_of::<MlirOperation>(),
        8usize,
        concat!("Size of: ", stringify!(MlirOperation))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOperation>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOperation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperation>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperation),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpPrintingFlags {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirOpPrintingFlags() {
    assert_eq!(
        ::std::mem::size_of::<MlirOpPrintingFlags>(),
        8usize,
        concat!("Size of: ", stringify!(MlirOpPrintingFlags))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOpPrintingFlags>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOpPrintingFlags))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOpPrintingFlags>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOpPrintingFlags),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirBlock {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirBlock() {
    assert_eq!(
        ::std::mem::size_of::<MlirBlock>(),
        8usize,
        concat!("Size of: ", stringify!(MlirBlock))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirBlock>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirBlock))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirBlock>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirBlock),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirRegion {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirRegion() {
    assert_eq!(
        ::std::mem::size_of::<MlirRegion>(),
        8usize,
        concat!("Size of: ", stringify!(MlirRegion))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirRegion>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirRegion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirRegion>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirRegion),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAttribute {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirAttribute() {
    assert_eq!(
        ::std::mem::size_of::<MlirAttribute>(),
        8usize,
        concat!("Size of: ", stringify!(MlirAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirAttribute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirAttribute>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirAttribute),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirIdentifier {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirIdentifier() {
    assert_eq!(
        ::std::mem::size_of::<MlirIdentifier>(),
        8usize,
        concat!("Size of: ", stringify!(MlirIdentifier))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirIdentifier>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirIdentifier))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirIdentifier>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirIdentifier),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirLocation {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirLocation() {
    assert_eq!(
        ::std::mem::size_of::<MlirLocation>(),
        8usize,
        concat!("Size of: ", stringify!(MlirLocation))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirLocation>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirLocation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirLocation>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirLocation),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirModule {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirModule() {
    assert_eq!(
        ::std::mem::size_of::<MlirModule>(),
        8usize,
        concat!("Size of: ", stringify!(MlirModule))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirModule>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirModule))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirModule>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirModule),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirType {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirType() {
    assert_eq!(
        ::std::mem::size_of::<MlirType>(),
        8usize,
        concat!("Size of: ", stringify!(MlirType))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirType>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirType))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirType>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirType),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirValue {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirValue() {
    assert_eq!(
        ::std::mem::size_of::<MlirValue>(),
        8usize,
        concat!("Size of: ", stringify!(MlirValue))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirValue>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirValue))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirValue>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirValue),
            "::",
            stringify!(ptr)
        )
    );
}
#[doc = " Named MLIR attribute."]
#[doc = ""]
#[doc = " A named attribute is essentially a (name, attribute) pair where the name is"]
#[doc = " a string."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirNamedAttribute {
    pub name: MlirIdentifier,
    pub attribute: MlirAttribute,
}
#[test]
fn bindgen_test_layout_MlirNamedAttribute() {
    assert_eq!(
        ::std::mem::size_of::<MlirNamedAttribute>(),
        16usize,
        concat!("Size of: ", stringify!(MlirNamedAttribute))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirNamedAttribute>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirNamedAttribute))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirNamedAttribute>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirNamedAttribute),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirNamedAttribute>())).attribute as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirNamedAttribute),
            "::",
            stringify!(attribute)
        )
    );
}
extern "C" {
    #[doc = " Creates an MLIR context and transfers its ownership to the caller."]
    pub fn mlirContextCreate() -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two contexts are equal."]
    pub fn mlirContextEqual(ctx1: MlirContext, ctx2: MlirContext) -> bool;
}
extern "C" {
    #[doc = " Takes an MLIR context owned by the caller and destroys it."]
    pub fn mlirContextDestroy(context: MlirContext);
}
extern "C" {
    #[doc = " Sets whether unregistered dialects are allowed in this context."]
    pub fn mlirContextSetAllowUnregisteredDialects(context: MlirContext, allow: bool);
}
extern "C" {
    #[doc = " Returns whether the context allows unregistered dialects."]
    pub fn mlirContextGetAllowUnregisteredDialects(context: MlirContext) -> bool;
}
extern "C" {
    #[doc = " Returns the number of dialects registered with the given context. A"]
    #[doc = " registered dialect will be loaded if needed by the parser."]
    pub fn mlirContextGetNumRegisteredDialects(context: MlirContext) -> isize;
}
extern "C" {
    #[doc = " Returns the number of dialects loaded by the context."]
    pub fn mlirContextGetNumLoadedDialects(context: MlirContext) -> isize;
}
extern "C" {
    #[doc = " Gets the dialect instance owned by the given context using the dialect"]
    #[doc = " namespace to identify it, loads (i.e., constructs the instance of) the"]
    #[doc = " dialect if necessary. If the dialect is not registered with the context,"]
    #[doc = " returns null. Use mlirContextLoad<Name>Dialect to load an unregistered"]
    #[doc = " dialect."]
    pub fn mlirContextGetOrLoadDialect(context: MlirContext, name: MlirStringRef) -> MlirDialect;
}
extern "C" {
    #[doc = " Set threading mode (must be set to false to print-ir-after-all)."]
    pub fn mlirContextEnableMultithreading(context: MlirContext, enable: bool);
}
extern "C" {
    #[doc = " Returns whether the given fully-qualified operation (i.e."]
    #[doc = " 'dialect.operation') is registered with the context. This will return true"]
    #[doc = " if the dialect is loaded and the operation is registered within the"]
    #[doc = " dialect."]
    pub fn mlirContextIsRegisteredOperation(context: MlirContext, name: MlirStringRef) -> bool;
}
extern "C" {
    #[doc = " Returns the context that owns the dialect."]
    pub fn mlirDialectGetContext(dialect: MlirDialect) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two dialects that belong to the same context are equal. Dialects"]
    #[doc = " from different contexts will not compare equal."]
    pub fn mlirDialectEqual(dialect1: MlirDialect, dialect2: MlirDialect) -> bool;
}
extern "C" {
    #[doc = " Returns the namespace of the given dialect."]
    pub fn mlirDialectGetNamespace(dialect: MlirDialect) -> MlirStringRef;
}
extern "C" {
    #[doc = " Creates an File/Line/Column location owned by the given context."]
    pub fn mlirLocationFileLineColGet(
        context: MlirContext,
        filename: MlirStringRef,
        line: ::std::os::raw::c_uint,
        col: ::std::os::raw::c_uint,
    ) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates a call site location with a callee and a caller."]
    pub fn mlirLocationCallSiteGet(callee: MlirLocation, caller: MlirLocation) -> MlirLocation;
}
extern "C" {
    #[doc = " Creates a location with unknown position owned by the given context."]
    pub fn mlirLocationUnknownGet(context: MlirContext) -> MlirLocation;
}
extern "C" {
    #[doc = " Gets the context that a location was created with."]
    pub fn mlirLocationGetContext(location: MlirLocation) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two locations are equal."]
    pub fn mlirLocationEqual(l1: MlirLocation, l2: MlirLocation) -> bool;
}
extern "C" {
    #[doc = " Prints a location by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirLocationPrint(
        location: MlirLocation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Creates a new, empty module and transfers ownership to the caller."]
    pub fn mlirModuleCreateEmpty(location: MlirLocation) -> MlirModule;
}
extern "C" {
    #[doc = " Parses a module from the string and transfers ownership to the caller."]
    pub fn mlirModuleCreateParse(context: MlirContext, module: MlirStringRef) -> MlirModule;
}
extern "C" {
    #[doc = " Gets the context that a module was created with."]
    pub fn mlirModuleGetContext(module: MlirModule) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the body of the module, i.e. the only block it contains."]
    pub fn mlirModuleGetBody(module: MlirModule) -> MlirBlock;
}
extern "C" {
    #[doc = " Takes a module owned by the caller and deletes it."]
    pub fn mlirModuleDestroy(module: MlirModule);
}
extern "C" {
    #[doc = " Views the module as a generic operation."]
    pub fn mlirModuleGetOperation(module: MlirModule) -> MlirOperation;
}
extern "C" {
    #[doc = " Views the generic operation as a module."]
    #[doc = " The returned module is null when the input operation was not a ModuleOp."]
    pub fn mlirModuleFromOperation(op: MlirOperation) -> MlirModule;
}
#[doc = " An auxiliary class for constructing operations."]
#[doc = ""]
#[doc = " This class contains all the information necessary to construct the"]
#[doc = " operation. It owns the MlirRegions it has pointers to and does not own"]
#[doc = " anything else. By default, the state can be constructed from a name and"]
#[doc = " location, the latter being also used to access the context, and has no other"]
#[doc = " components. These components can be added progressively until the operation"]
#[doc = " is constructed. Users are not expected to rely on the internals of this"]
#[doc = " class and should use mlirOperationState* functions instead."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOperationState {
    pub name: MlirStringRef,
    pub location: MlirLocation,
    pub nResults: isize,
    pub results: *mut MlirType,
    pub nOperands: isize,
    pub operands: *mut MlirValue,
    pub nRegions: isize,
    pub regions: *mut MlirRegion,
    pub nSuccessors: isize,
    pub successors: *mut MlirBlock,
    pub nAttributes: isize,
    pub attributes: *mut MlirNamedAttribute,
    pub enableResultTypeInference: bool,
}
#[test]
fn bindgen_test_layout_MlirOperationState() {
    assert_eq!(
        ::std::mem::size_of::<MlirOperationState>(),
        112usize,
        concat!("Size of: ", stringify!(MlirOperationState))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOperationState>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOperationState))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).location as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(location)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).nResults as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nResults)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).results as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(results)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).nOperands as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nOperands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).operands as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(operands)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).nRegions as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nRegions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).regions as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(regions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).nSuccessors as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nSuccessors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).successors as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(successors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).nAttributes as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(nAttributes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOperationState>())).attributes as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(attributes)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MlirOperationState>())).enableResultTypeInference as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOperationState),
            "::",
            stringify!(enableResultTypeInference)
        )
    );
}
extern "C" {
    #[doc = " Constructs an operation state from a name and a location."]
    pub fn mlirOperationStateGet(name: MlirStringRef, loc: MlirLocation) -> MlirOperationState;
}
extern "C" {
    #[doc = " Adds a list of components to the operation state."]
    pub fn mlirOperationStateAddResults(
        state: *mut MlirOperationState,
        n: isize,
        results: *const MlirType,
    );
}
extern "C" {
    pub fn mlirOperationStateAddOperands(
        state: *mut MlirOperationState,
        n: isize,
        operands: *const MlirValue,
    );
}
extern "C" {
    pub fn mlirOperationStateAddOwnedRegions(
        state: *mut MlirOperationState,
        n: isize,
        regions: *const MlirRegion,
    );
}
extern "C" {
    pub fn mlirOperationStateAddSuccessors(
        state: *mut MlirOperationState,
        n: isize,
        successors: *const MlirBlock,
    );
}
extern "C" {
    pub fn mlirOperationStateAddAttributes(
        state: *mut MlirOperationState,
        n: isize,
        attributes: *const MlirNamedAttribute,
    );
}
extern "C" {
    #[doc = " Enables result type inference for the operation under construction. If"]
    #[doc = " enabled, then the caller must not have called"]
    #[doc = " mlirOperationStateAddResults(). Note that if enabled, the"]
    #[doc = " mlirOperationCreate() call is failable: it will return a null operation"]
    #[doc = " on inference failure and will emit diagnostics."]
    pub fn mlirOperationStateEnableResultTypeInference(state: *mut MlirOperationState);
}
extern "C" {
    #[doc = " Creates new printing flags with defaults, intended for customization."]
    #[doc = " Must be freed with a call to mlirOpPrintingFlagsDestroy()."]
    pub fn mlirOpPrintingFlagsCreate() -> MlirOpPrintingFlags;
}
extern "C" {
    #[doc = " Destroys printing flags created with mlirOpPrintingFlagsCreate."]
    pub fn mlirOpPrintingFlagsDestroy(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Enables the elision of large elements attributes by printing a lexically"]
    #[doc = " valid but otherwise meaningless form instead of the element data. The"]
    #[doc = " `largeElementLimit` is used to configure what is considered to be a \"large\""]
    #[doc = " ElementsAttr by providing an upper limit to the number of elements."]
    pub fn mlirOpPrintingFlagsElideLargeElementsAttrs(
        flags: MlirOpPrintingFlags,
        largeElementLimit: isize,
    );
}
extern "C" {
    #[doc = " Enable printing of debug information. If 'prettyForm' is set to true,"]
    #[doc = " debug information is printed in a more readable 'pretty' form. Note: The"]
    #[doc = " IR generated with 'prettyForm' is not parsable."]
    pub fn mlirOpPrintingFlagsEnableDebugInfo(flags: MlirOpPrintingFlags, prettyForm: bool);
}
extern "C" {
    #[doc = " Always print operations in the generic form."]
    pub fn mlirOpPrintingFlagsPrintGenericOpForm(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Use local scope when printing the operation. This allows for using the"]
    #[doc = " printer in a more localized and thread-safe setting, but may not"]
    #[doc = " necessarily be identical to what the IR will look like when dumping"]
    #[doc = " the full module."]
    pub fn mlirOpPrintingFlagsUseLocalScope(flags: MlirOpPrintingFlags);
}
extern "C" {
    #[doc = " Creates an operation and transfers ownership to the caller."]
    #[doc = " Note that caller owned child objects are transferred in this call and must"]
    #[doc = " not be further used. Particularly, this applies to any regions added to"]
    #[doc = " the state (the implementation may invalidate any such pointers)."]
    #[doc = ""]
    #[doc = " This call can fail under the following conditions, in which case, it will"]
    #[doc = " return a null operation and emit diagnostics:"]
    #[doc = "   - Result type inference is enabled and cannot be performed."]
    pub fn mlirOperationCreate(state: *mut MlirOperationState) -> MlirOperation;
}
extern "C" {
    #[doc = " Creates a deep copy of an operation. The operation is not inserted and"]
    #[doc = " ownership is transferred to the caller."]
    pub fn mlirOperationClone(op: MlirOperation) -> MlirOperation;
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and destroys it."]
    pub fn mlirOperationDestroy(op: MlirOperation);
}
extern "C" {
    #[doc = " Checks whether two operation handles point to the same operation. This does"]
    #[doc = " not perform deep comparison."]
    pub fn mlirOperationEqual(op: MlirOperation, other: MlirOperation) -> bool;
}
extern "C" {
    #[doc = " Gets the context this operation is associated with"]
    pub fn mlirOperationGetContext(op: MlirOperation) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the name of the operation as an identifier."]
    pub fn mlirOperationGetName(op: MlirOperation) -> MlirIdentifier;
}
extern "C" {
    #[doc = " Gets the block that owns this operation, returning null if the operation is"]
    #[doc = " not owned."]
    pub fn mlirOperationGetBlock(op: MlirOperation) -> MlirBlock;
}
extern "C" {
    #[doc = " Gets the operation that owns this operation, returning null if the operation"]
    #[doc = " is not owned."]
    pub fn mlirOperationGetParentOperation(op: MlirOperation) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the number of regions attached to the given operation."]
    pub fn mlirOperationGetNumRegions(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th region attached to the operation."]
    pub fn mlirOperationGetRegion(op: MlirOperation, pos: isize) -> MlirRegion;
}
extern "C" {
    #[doc = " Returns an operation immediately following the given operation it its"]
    #[doc = " enclosing block."]
    pub fn mlirOperationGetNextInBlock(op: MlirOperation) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the number of operands of the operation."]
    pub fn mlirOperationGetNumOperands(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th operand of the operation."]
    pub fn mlirOperationGetOperand(op: MlirOperation, pos: isize) -> MlirValue;
}
extern "C" {
    #[doc = " Sets the `pos`-th operand of the operation."]
    pub fn mlirOperationSetOperand(op: MlirOperation, pos: isize, newValue: MlirValue);
}
extern "C" {
    #[doc = " Returns the number of results of the operation."]
    pub fn mlirOperationGetNumResults(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th result of the operation."]
    pub fn mlirOperationGetResult(op: MlirOperation, pos: isize) -> MlirValue;
}
extern "C" {
    #[doc = " Returns the number of successor blocks of the operation."]
    pub fn mlirOperationGetNumSuccessors(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th successor of the operation."]
    pub fn mlirOperationGetSuccessor(op: MlirOperation, pos: isize) -> MlirBlock;
}
extern "C" {
    #[doc = " Returns the number of attributes attached to the operation."]
    pub fn mlirOperationGetNumAttributes(op: MlirOperation) -> isize;
}
extern "C" {
    #[doc = " Return `pos`-th attribute of the operation."]
    pub fn mlirOperationGetAttribute(op: MlirOperation, pos: isize) -> MlirNamedAttribute;
}
extern "C" {
    #[doc = " Returns an attribute attached to the operation given its name."]
    pub fn mlirOperationGetAttributeByName(op: MlirOperation, name: MlirStringRef)
        -> MlirAttribute;
}
extern "C" {
    #[doc = " Sets an attribute by name, replacing the existing if it exists or"]
    #[doc = " adding a new one otherwise."]
    pub fn mlirOperationSetAttributeByName(
        op: MlirOperation,
        name: MlirStringRef,
        attr: MlirAttribute,
    );
}
extern "C" {
    #[doc = " Removes an attribute by name. Returns false if the attribute was not found"]
    #[doc = " and true if removed."]
    pub fn mlirOperationRemoveAttributeByName(op: MlirOperation, name: MlirStringRef) -> bool;
}
extern "C" {
    #[doc = " Prints an operation by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirOperationPrint(
        op: MlirOperation,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Same as mlirOperationPrint but accepts flags controlling the printing"]
    #[doc = " behavior."]
    pub fn mlirOperationPrintWithFlags(
        op: MlirOperation,
        flags: MlirOpPrintingFlags,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints an operation to stderr."]
    pub fn mlirOperationDump(op: MlirOperation);
}
extern "C" {
    #[doc = " Verify the operation and return true if it passes, false if it fails."]
    pub fn mlirOperationVerify(op: MlirOperation) -> bool;
}
extern "C" {
    #[doc = " Creates a new empty region and transfers ownership to the caller."]
    pub fn mlirRegionCreate() -> MlirRegion;
}
extern "C" {
    #[doc = " Takes a region owned by the caller and destroys it."]
    pub fn mlirRegionDestroy(region: MlirRegion);
}
extern "C" {
    #[doc = " Gets the first block in the region."]
    pub fn mlirRegionGetFirstBlock(region: MlirRegion) -> MlirBlock;
}
extern "C" {
    #[doc = " Takes a block owned by the caller and appends it to the given region."]
    pub fn mlirRegionAppendOwnedBlock(region: MlirRegion, block: MlirBlock);
}
extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it at `pos` to the given"]
    #[doc = " region. This is an expensive operation that linearly scans the region,"]
    #[doc = " prefer insertAfter/Before instead."]
    pub fn mlirRegionInsertOwnedBlock(region: MlirRegion, pos: isize, block: MlirBlock);
}
extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it after the (non-owned)"]
    #[doc = " reference block in the given region. The reference block must belong to the"]
    #[doc = " region. If the reference block is null, prepends the block to the region."]
    pub fn mlirRegionInsertOwnedBlockAfter(
        region: MlirRegion,
        reference: MlirBlock,
        block: MlirBlock,
    );
}
extern "C" {
    #[doc = " Takes a block owned by the caller and inserts it before the (non-owned)"]
    #[doc = " reference block in the given region. The reference block must belong to the"]
    #[doc = " region. If the reference block is null, appends the block to the region."]
    pub fn mlirRegionInsertOwnedBlockBefore(
        region: MlirRegion,
        reference: MlirBlock,
        block: MlirBlock,
    );
}
extern "C" {
    #[doc = " Creates a new empty block with the given argument types and transfers"]
    #[doc = " ownership to the caller."]
    pub fn mlirBlockCreate(nArgs: isize, args: *const MlirType) -> MlirBlock;
}
extern "C" {
    #[doc = " Takes a block owned by the caller and destroys it."]
    pub fn mlirBlockDestroy(block: MlirBlock);
}
extern "C" {
    #[doc = " Checks whether two blocks handles point to the same block. This does not"]
    #[doc = " perform deep comparison."]
    pub fn mlirBlockEqual(block: MlirBlock, other: MlirBlock) -> bool;
}
extern "C" {
    #[doc = " Returns the closest surrounding operation that contains this block."]
    pub fn mlirBlockGetParentOperation(arg1: MlirBlock) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the block immediately following the given block in its parent"]
    #[doc = " region."]
    pub fn mlirBlockGetNextInRegion(block: MlirBlock) -> MlirBlock;
}
extern "C" {
    #[doc = " Returns the first operation in the block."]
    pub fn mlirBlockGetFirstOperation(block: MlirBlock) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the terminator operation in the block or null if no terminator."]
    pub fn mlirBlockGetTerminator(block: MlirBlock) -> MlirOperation;
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and appends it to the block."]
    pub fn mlirBlockAppendOwnedOperation(block: MlirBlock, operation: MlirOperation);
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it as `pos` to the block."]
    #[doc = " This is an expensive operation that scans the block linearly, prefer"]
    #[doc = " insertBefore/After instead."]
    pub fn mlirBlockInsertOwnedOperation(block: MlirBlock, pos: isize, operation: MlirOperation);
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it after the (non-owned)"]
    #[doc = " reference operation in the given block. If the reference is null, prepends"]
    #[doc = " the operation. Otherwise, the reference must belong to the block."]
    pub fn mlirBlockInsertOwnedOperationAfter(
        block: MlirBlock,
        reference: MlirOperation,
        operation: MlirOperation,
    );
}
extern "C" {
    #[doc = " Takes an operation owned by the caller and inserts it before the (non-owned)"]
    #[doc = " reference operation in the given block. If the reference is null, appends"]
    #[doc = " the operation. Otherwise, the reference must belong to the block."]
    pub fn mlirBlockInsertOwnedOperationBefore(
        block: MlirBlock,
        reference: MlirOperation,
        operation: MlirOperation,
    );
}
extern "C" {
    #[doc = " Returns the number of arguments of the block."]
    pub fn mlirBlockGetNumArguments(block: MlirBlock) -> isize;
}
extern "C" {
    #[doc = " Appends an argument of the specified type to the block. Returns the newly"]
    #[doc = " added argument."]
    pub fn mlirBlockAddArgument(block: MlirBlock, type_: MlirType) -> MlirValue;
}
extern "C" {
    #[doc = " Returns `pos`-th argument of the block."]
    pub fn mlirBlockGetArgument(block: MlirBlock, pos: isize) -> MlirValue;
}
extern "C" {
    #[doc = " Prints a block by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirBlockPrint(
        block: MlirBlock,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns 1 if two values are equal, 0 otherwise."]
    pub fn mlirValueEqual(value1: MlirValue, value2: MlirValue) -> bool;
}
extern "C" {
    #[doc = " Returns 1 if the value is a block argument, 0 otherwise."]
    pub fn mlirValueIsABlockArgument(value: MlirValue) -> bool;
}
extern "C" {
    #[doc = " Returns 1 if the value is an operation result, 0 otherwise."]
    pub fn mlirValueIsAOpResult(value: MlirValue) -> bool;
}
extern "C" {
    #[doc = " Returns the block in which this value is defined as an argument. Asserts if"]
    #[doc = " the value is not a block argument."]
    pub fn mlirBlockArgumentGetOwner(value: MlirValue) -> MlirBlock;
}
extern "C" {
    #[doc = " Returns the position of the value in the argument list of its block."]
    pub fn mlirBlockArgumentGetArgNumber(value: MlirValue) -> isize;
}
extern "C" {
    #[doc = " Sets the type of the block argument to the given type."]
    pub fn mlirBlockArgumentSetType(value: MlirValue, type_: MlirType);
}
extern "C" {
    #[doc = " Returns an operation that produced this value as its result. Asserts if the"]
    #[doc = " value is not an op result."]
    pub fn mlirOpResultGetOwner(value: MlirValue) -> MlirOperation;
}
extern "C" {
    #[doc = " Returns the position of the value in the list of results of the operation"]
    #[doc = " that produced it."]
    pub fn mlirOpResultGetResultNumber(value: MlirValue) -> isize;
}
extern "C" {
    #[doc = " Returns the type of the value."]
    pub fn mlirValueGetType(value: MlirValue) -> MlirType;
}
extern "C" {
    #[doc = " Prints the value to the standard error stream."]
    pub fn mlirValueDump(value: MlirValue);
}
extern "C" {
    #[doc = " Prints a value by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirValuePrint(
        value: MlirValue,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Parses a type. The type is owned by the context."]
    pub fn mlirTypeParseGet(context: MlirContext, type_: MlirStringRef) -> MlirType;
}
extern "C" {
    #[doc = " Gets the context that a type was created with."]
    pub fn mlirTypeGetContext(type_: MlirType) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two types are equal."]
    pub fn mlirTypeEqual(t1: MlirType, t2: MlirType) -> bool;
}
extern "C" {
    #[doc = " Prints a location by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirTypePrint(
        type_: MlirType,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints the type to the standard error stream."]
    pub fn mlirTypeDump(type_: MlirType);
}
extern "C" {
    #[doc = " Parses an attribute. The attribute is owned by the context."]
    pub fn mlirAttributeParseGet(context: MlirContext, attr: MlirStringRef) -> MlirAttribute;
}
extern "C" {
    #[doc = " Gets the context that an attribute was created with."]
    pub fn mlirAttributeGetContext(attribute: MlirAttribute) -> MlirContext;
}
extern "C" {
    #[doc = " Gets the type of this attribute."]
    pub fn mlirAttributeGetType(attribute: MlirAttribute) -> MlirType;
}
extern "C" {
    #[doc = " Checks if two attributes are equal."]
    pub fn mlirAttributeEqual(a1: MlirAttribute, a2: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Prints an attribute by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirAttributePrint(
        attr: MlirAttribute,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints the attribute to the standard error stream."]
    pub fn mlirAttributeDump(attr: MlirAttribute);
}
extern "C" {
    #[doc = " Associates an attribute with the name. Takes ownership of neither."]
    pub fn mlirNamedAttributeGet(name: MlirIdentifier, attr: MlirAttribute) -> MlirNamedAttribute;
}
extern "C" {
    #[doc = " Gets an identifier with the given string value."]
    pub fn mlirIdentifierGet(context: MlirContext, str_: MlirStringRef) -> MlirIdentifier;
}
extern "C" {
    #[doc = " Returns the context associated with this identifier"]
    pub fn mlirIdentifierGetContext(arg1: MlirIdentifier) -> MlirContext;
}
extern "C" {
    #[doc = " Checks whether two identifiers are the same."]
    pub fn mlirIdentifierEqual(ident: MlirIdentifier, other: MlirIdentifier) -> bool;
}
extern "C" {
    #[doc = " Gets the string value of the identifier."]
    pub fn mlirIdentifierStr(ident: MlirIdentifier) -> MlirStringRef;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDialectHandle {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirDialectHandle() {
    assert_eq!(
        ::std::mem::size_of::<MlirDialectHandle>(),
        8usize,
        concat!("Size of: ", stringify!(MlirDialectHandle))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirDialectHandle>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirDialectHandle))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirDialectHandle>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirDialectHandle),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Returns the namespace associated with the provided dialect handle."]
    pub fn mlirDialectHandleGetNamespace(arg1: MlirDialectHandle) -> MlirStringRef;
}
extern "C" {
    #[doc = " Registers the dialect associated with the provided dialect handle."]
    pub fn mlirDialectHandleRegisterDialect(arg1: MlirDialectHandle, arg2: MlirContext);
}
extern "C" {
    #[doc = " Loads the dialect associated with the provided dialect handle."]
    pub fn mlirDialectHandleLoadDialect(arg1: MlirDialectHandle, arg2: MlirContext) -> MlirDialect;
}
extern "C" {
    #[doc = " Registers all dialects known to core MLIR with the provided Context."]
    #[doc = " This is needed before creating IR for these Dialects."]
    #[doc = " TODO: Remove this function once the real registration API is finished."]
    pub fn mlirRegisterAllDialects(context: MlirContext);
}
extern "C" {
    #[doc = " Register all translations to LLVM IR for dialects that can support it."]
    pub fn mlirRegisterAllLLVMTranslations(context: MlirContext);
}
extern "C" {
    #[doc = " Register all compiler passes of MLIR."]
    pub fn mlirRegisterAllPasses();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPass {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirPass() {
    assert_eq!(
        ::std::mem::size_of::<MlirPass>(),
        8usize,
        concat!("Size of: ", stringify!(MlirPass))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirPass>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirPass))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirPass>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirPass),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirPassManager {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirPassManager() {
    assert_eq!(
        ::std::mem::size_of::<MlirPassManager>(),
        8usize,
        concat!("Size of: ", stringify!(MlirPassManager))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirPassManager>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirPassManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirPassManager>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirPassManager),
            "::",
            stringify!(ptr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirOpPassManager {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirOpPassManager() {
    assert_eq!(
        ::std::mem::size_of::<MlirOpPassManager>(),
        8usize,
        concat!("Size of: ", stringify!(MlirOpPassManager))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirOpPassManager>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirOpPassManager))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirOpPassManager>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirOpPassManager),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Create a new top-level PassManager."]
    pub fn mlirPassManagerCreate(ctx: MlirContext) -> MlirPassManager;
}
extern "C" {
    #[doc = " Destroy the provided PassManager."]
    pub fn mlirPassManagerDestroy(passManager: MlirPassManager);
}
extern "C" {
    #[doc = " Cast a top-level PassManager to a generic OpPassManager."]
    pub fn mlirPassManagerGetAsOpPassManager(passManager: MlirPassManager) -> MlirOpPassManager;
}
extern "C" {
    #[doc = " Run the provided `passManager` on the given `module`."]
    pub fn mlirPassManagerRun(
        passManager: MlirPassManager,
        module: MlirModule,
    ) -> MlirLogicalResult;
}
extern "C" {
    #[doc = " Enable print-ir-after-all."]
    pub fn mlirPassManagerEnableIRPrinting(passManager: MlirPassManager);
}
extern "C" {
    #[doc = " Enable / disable verify-each."]
    pub fn mlirPassManagerEnableVerifier(passManager: MlirPassManager, enable: bool);
}
extern "C" {
    #[doc = " Nest an OpPassManager under the top-level PassManager, the nested"]
    #[doc = " passmanager will only run on operations matching the provided name."]
    #[doc = " The returned OpPassManager will be destroyed when the parent is destroyed."]
    #[doc = " To further nest more OpPassManager under the newly returned one, see"]
    #[doc = " `mlirOpPassManagerNest` below."]
    pub fn mlirPassManagerGetNestedUnder(
        passManager: MlirPassManager,
        operationName: MlirStringRef,
    ) -> MlirOpPassManager;
}
extern "C" {
    #[doc = " Nest an OpPassManager under the provided OpPassManager, the nested"]
    #[doc = " passmanager will only run on operations matching the provided name."]
    #[doc = " The returned OpPassManager will be destroyed when the parent is destroyed."]
    pub fn mlirOpPassManagerGetNestedUnder(
        passManager: MlirOpPassManager,
        operationName: MlirStringRef,
    ) -> MlirOpPassManager;
}
extern "C" {
    #[doc = " Add a pass and transfer ownership to the provided top-level mlirPassManager."]
    #[doc = " If the pass is not a generic operation pass or a ModulePass, a new"]
    #[doc = " OpPassManager is implicitly nested under the provided PassManager."]
    pub fn mlirPassManagerAddOwnedPass(passManager: MlirPassManager, pass: MlirPass);
}
extern "C" {
    #[doc = " Add a pass and transfer ownership to the provided mlirOpPassManager. If the"]
    #[doc = " pass is not a generic operation pass or matching the type of the provided"]
    #[doc = " PassManager, a new OpPassManager is implicitly nested under the provided"]
    #[doc = " PassManager."]
    pub fn mlirOpPassManagerAddOwnedPass(passManager: MlirOpPassManager, pass: MlirPass);
}
extern "C" {
    #[doc = " Print a textual MLIR pass pipeline by sending chunks of the string"]
    #[doc = " representation and forwarding `userData to `callback`. Note that the"]
    #[doc = " callback may be called several times with consecutive chunks of the string."]
    pub fn mlirPrintPassPipeline(
        passManager: MlirOpPassManager,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Parse a textual MLIR pass pipeline and add it to the provided OpPassManager."]
    pub fn mlirParsePassPipeline(
        passManager: MlirOpPassManager,
        pipeline: MlirStringRef,
    ) -> MlirLogicalResult;
}
extern "C" {
    pub fn mlirRegisterTransformsPasses();
}
extern "C" {
    pub fn mlirCreateTransformsAffineLoopFusion() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsAffineLoopFusion();
}
extern "C" {
    pub fn mlirCreateTransformsAffinePipelineDataTransfer() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsAffinePipelineDataTransfer();
}
extern "C" {
    pub fn mlirCreateTransformsBufferDeallocation() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsBufferDeallocation();
}
extern "C" {
    pub fn mlirCreateTransformsBufferHoisting() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsBufferHoisting();
}
extern "C" {
    pub fn mlirCreateTransformsBufferLoopHoisting() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsBufferLoopHoisting();
}
extern "C" {
    pub fn mlirCreateTransformsBufferResultsToOutParams() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsBufferResultsToOutParams();
}
extern "C" {
    pub fn mlirCreateTransformsCSE() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsCSE();
}
extern "C" {
    pub fn mlirCreateTransformsCanonicalizer() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsCanonicalizer();
}
extern "C" {
    pub fn mlirCreateTransformsFinalizingBufferize() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsFinalizingBufferize();
}
extern "C" {
    pub fn mlirCreateTransformsInliner() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsInliner();
}
extern "C" {
    pub fn mlirCreateTransformsLocationSnapshot() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsLocationSnapshot();
}
extern "C" {
    pub fn mlirCreateTransformsLoopCoalescing() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsLoopCoalescing();
}
extern "C" {
    pub fn mlirCreateTransformsLoopInvariantCodeMotion() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsLoopInvariantCodeMotion();
}
extern "C" {
    pub fn mlirCreateTransformsNormalizeMemRefs() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsNormalizeMemRefs();
}
extern "C" {
    pub fn mlirCreateTransformsParallelLoopCollapsing() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsParallelLoopCollapsing();
}
extern "C" {
    pub fn mlirCreateTransformsPrintCFG() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsPrintCFG();
}
extern "C" {
    pub fn mlirCreateTransformsPrintOpStats() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsPrintOpStats();
}
extern "C" {
    pub fn mlirCreateTransformsPromoteBuffersToStack() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsPromoteBuffersToStack();
}
extern "C" {
    pub fn mlirCreateTransformsSCCP() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsSCCP();
}
extern "C" {
    pub fn mlirCreateTransformsStripDebugInfo() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsStripDebugInfo();
}
extern "C" {
    pub fn mlirCreateTransformsSymbolDCE() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsSymbolDCE();
}
extern "C" {
    pub fn mlirCreateTransformsViewOpGraphPass() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterTransformsViewOpGraphPass();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAffineExpr {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirAffineExpr() {
    assert_eq!(
        ::std::mem::size_of::<MlirAffineExpr>(),
        8usize,
        concat!("Size of: ", stringify!(MlirAffineExpr))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirAffineExpr>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirAffineExpr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirAffineExpr>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirAffineExpr),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Gets the context that owns the affine expression."]
    pub fn mlirAffineExprGetContext(affineExpr: MlirAffineExpr) -> MlirContext;
}
extern "C" {
    #[doc = " Returns `true` if the two affine expressions are equal."]
    pub fn mlirAffineExprEqual(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Prints an affine expression by sending chunks of the string representation"]
    #[doc = " and forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirAffineExprPrint(
        affineExpr: MlirAffineExpr,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints the affine expression to the standard error stream."]
    pub fn mlirAffineExprDump(affineExpr: MlirAffineExpr);
}
extern "C" {
    #[doc = " Checks whether the given affine expression is made out of only symbols and"]
    #[doc = " constants."]
    pub fn mlirAffineExprIsSymbolicOrConstant(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is a pure affine expression, i.e."]
    #[doc = " mul, floordiv, ceildic, and mod is only allowed w.r.t constants."]
    pub fn mlirAffineExprIsPureAffine(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Returns the greatest known integral divisor of this affine expression. The"]
    #[doc = " result is always positive."]
    pub fn mlirAffineExprGetLargestKnownDivisor(affineExpr: MlirAffineExpr) -> i64;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is a multiple of 'factor'."]
    pub fn mlirAffineExprIsMultipleOf(affineExpr: MlirAffineExpr, factor: i64) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine expression involves AffineDimExpr"]
    #[doc = " 'position'."]
    pub fn mlirAffineExprIsFunctionOfDim(affineExpr: MlirAffineExpr, position: isize) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is a dimension expression."]
    pub fn mlirAffineExprIsADim(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine dimension expression with 'position' in the context."]
    pub fn mlirAffineDimExprGet(ctx: MlirContext, position: isize) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Returns the position of the given affine dimension expression."]
    pub fn mlirAffineDimExprGetPosition(affineExpr: MlirAffineExpr) -> isize;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is a symbol expression."]
    pub fn mlirAffineExprIsASymbol(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine symbol expression with 'position' in the context."]
    pub fn mlirAffineSymbolExprGet(ctx: MlirContext, position: isize) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Returns the position of the given affine symbol expression."]
    pub fn mlirAffineSymbolExprGetPosition(affineExpr: MlirAffineExpr) -> isize;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is a constant expression."]
    pub fn mlirAffineExprIsAConstant(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine constant expression with 'constant' in the context."]
    pub fn mlirAffineConstantExprGet(ctx: MlirContext, constant: i64) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Returns the value of the given affine constant expression."]
    pub fn mlirAffineConstantExprGetValue(affineExpr: MlirAffineExpr) -> i64;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is an add expression."]
    pub fn mlirAffineExprIsAAdd(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine add expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineAddExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is an mul expression."]
    pub fn mlirAffineExprIsAMul(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine mul expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineMulExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is an mod expression."]
    pub fn mlirAffineExprIsAMod(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine mod expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineModExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is an floordiv expression."]
    pub fn mlirAffineExprIsAFloorDiv(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine floordiv expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineFloorDivExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is an ceildiv expression."]
    pub fn mlirAffineExprIsACeilDiv(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Creates an affine ceildiv expression with 'lhs' and 'rhs'."]
    pub fn mlirAffineCeilDivExprGet(lhs: MlirAffineExpr, rhs: MlirAffineExpr) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Checks whether the given affine expression is binary."]
    pub fn mlirAffineExprIsABinary(affineExpr: MlirAffineExpr) -> bool;
}
extern "C" {
    #[doc = " Returns the left hand side affine expression of the given affine binary"]
    #[doc = " operation expression."]
    pub fn mlirAffineBinaryOpExprGetLHS(affineExpr: MlirAffineExpr) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Returns the right hand side affine expression of the given affine binary"]
    #[doc = " operation expression."]
    pub fn mlirAffineBinaryOpExprGetRHS(affineExpr: MlirAffineExpr) -> MlirAffineExpr;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirIntegerSet {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirIntegerSet() {
    assert_eq!(
        ::std::mem::size_of::<MlirIntegerSet>(),
        8usize,
        concat!("Size of: ", stringify!(MlirIntegerSet))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirIntegerSet>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirIntegerSet))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirIntegerSet>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirIntegerSet),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Gets the context in which the given integer set lives."]
    pub fn mlirIntegerSetGetContext(set: MlirIntegerSet) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two integer set objects are equal. This is a \"shallow\" comparison"]
    #[doc = " of two objects. Only the sets with some small number of constraints are"]
    #[doc = " uniqued and compare equal here. Set objects that represent the same integer"]
    #[doc = " set with different constraints may be considered non-equal by this check."]
    #[doc = " Set difference followed by an (expensive) emptiness check should be used to"]
    #[doc = " check equivalence of the underlying integer sets."]
    pub fn mlirIntegerSetEqual(s1: MlirIntegerSet, s2: MlirIntegerSet) -> bool;
}
extern "C" {
    #[doc = " Prints an integer set by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirIntegerSetPrint(
        set: MlirIntegerSet,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints an integer set to the standard error stream."]
    pub fn mlirIntegerSetDump(set: MlirIntegerSet);
}
extern "C" {
    #[doc = " Gets or creates a new canonically empty integer set with the give number of"]
    #[doc = " dimensions and symbols in the given context."]
    pub fn mlirIntegerSetEmptyGet(
        context: MlirContext,
        numDims: isize,
        numSymbols: isize,
    ) -> MlirIntegerSet;
}
extern "C" {
    #[doc = " Gets or creates a new integer set in the given context. The set is defined"]
    #[doc = " by a list of affine constraints, with the given number of input dimensions"]
    #[doc = " and symbols, which are treated as either equalities (eqFlags is 1) or"]
    #[doc = " inequalities (eqFlags is 0). Both `constraints` and `eqFlags` are expected"]
    #[doc = " to point to at least `numConstraint` consecutive values."]
    pub fn mlirIntegerSetGet(
        context: MlirContext,
        numDims: isize,
        numSymbols: isize,
        numConstraints: isize,
        constraints: *const MlirAffineExpr,
        eqFlags: *const bool,
    ) -> MlirIntegerSet;
}
extern "C" {
    #[doc = " Gets or creates a new integer set in which the values and dimensions of the"]
    #[doc = " given set are replaced with the given affine expressions. `dimReplacements`"]
    #[doc = " and `symbolReplacements` are expected to point to at least as many"]
    #[doc = " consecutive expressions as the given set has dimensions and symbols,"]
    #[doc = " respectively. The new set will have `numResultDims` and `numResultSymbols`"]
    #[doc = " dimensions and symbols, respectively."]
    pub fn mlirIntegerSetReplaceGet(
        set: MlirIntegerSet,
        dimReplacements: *const MlirAffineExpr,
        symbolReplacements: *const MlirAffineExpr,
        numResultDims: isize,
        numResultSymbols: isize,
    ) -> MlirIntegerSet;
}
extern "C" {
    #[doc = " Checks whether the given set is a canonical empty set, e.g., the set"]
    #[doc = " returned by mlirIntegerSetEmptyGet."]
    pub fn mlirIntegerSetIsCanonicalEmpty(set: MlirIntegerSet) -> bool;
}
extern "C" {
    #[doc = " Returns the number of dimensions in the given set."]
    pub fn mlirIntegerSetGetNumDims(set: MlirIntegerSet) -> isize;
}
extern "C" {
    #[doc = " Returns the number of symbols in the given set."]
    pub fn mlirIntegerSetGetNumSymbols(set: MlirIntegerSet) -> isize;
}
extern "C" {
    #[doc = " Returns the number of inputs (dimensions + symbols) in the given set."]
    pub fn mlirIntegerSetGetNumInputs(set: MlirIntegerSet) -> isize;
}
extern "C" {
    #[doc = " Returns the number of constraints (equalities + inequalities) in the given"]
    #[doc = " set."]
    pub fn mlirIntegerSetGetNumConstraints(set: MlirIntegerSet) -> isize;
}
extern "C" {
    #[doc = " Returns the number of equalities in the given set."]
    pub fn mlirIntegerSetGetNumEqualities(set: MlirIntegerSet) -> isize;
}
extern "C" {
    #[doc = " Returns the number of inequalities in the given set."]
    pub fn mlirIntegerSetGetNumInequalities(set: MlirIntegerSet) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th constraint of the set."]
    pub fn mlirIntegerSetGetConstraint(set: MlirIntegerSet, pos: isize) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Returns `true` of the `pos`-th constraint of the set is an equality"]
    #[doc = " constraint, `false` otherwise."]
    pub fn mlirIntegerSetIsConstraintEq(set: MlirIntegerSet, pos: isize) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirExecutionEngine {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirExecutionEngine() {
    assert_eq!(
        ::std::mem::size_of::<MlirExecutionEngine>(),
        8usize,
        concat!("Size of: ", stringify!(MlirExecutionEngine))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirExecutionEngine>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirExecutionEngine))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirExecutionEngine>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirExecutionEngine),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Creates an ExecutionEngine for the provided ModuleOp. The ModuleOp is"]
    #[doc = " expected to be \"translatable\" to LLVM IR (only contains operations in"]
    #[doc = " dialects that implement the `LLVMTranslationDialectInterface`). The module"]
    #[doc = " ownership stays with the client and can be destroyed as soon as the call"]
    #[doc = " returns. `optLevel` is the optimization level to be used for transformation"]
    #[doc = " and code generation. LLVM passes at `optLevel` are run before code"]
    #[doc = " generation. The number and array of paths corresponding to shared libraries"]
    #[doc = " that will be loaded are specified via `numPaths` and `sharedLibPaths`"]
    #[doc = " respectively."]
    #[doc = " TODO: figure out other options."]
    pub fn mlirExecutionEngineCreate(
        op: MlirModule,
        optLevel: ::std::os::raw::c_int,
        numPaths: ::std::os::raw::c_int,
        sharedLibPaths: *const MlirStringRef,
    ) -> MlirExecutionEngine;
}
extern "C" {
    #[doc = " Destroy an ExecutionEngine instance."]
    pub fn mlirExecutionEngineDestroy(jit: MlirExecutionEngine);
}
extern "C" {
    #[doc = " Invoke a native function in the execution engine by name with the arguments"]
    #[doc = " and result of the invoked function passed as an array of pointers. The"]
    #[doc = " function must have been tagged with the `llvm.emit_c_interface` attribute."]
    #[doc = " Returns a failure if the execution fails for any reason (the function name"]
    #[doc = " can't be resolved for instance)."]
    pub fn mlirExecutionEngineInvokePacked(
        jit: MlirExecutionEngine,
        name: MlirStringRef,
        arguments: *mut *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult;
}
extern "C" {
    #[doc = " Lookup a native function in the execution engine by name, returns nullptr"]
    #[doc = " if the name can't be looked-up."]
    pub fn mlirExecutionEngineLookup(
        jit: MlirExecutionEngine,
        name: MlirStringRef,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Register a symbol with the jit: this symbol will be accessible to the jitted"]
    #[doc = " code."]
    pub fn mlirExecutionEngineRegisterSymbol(
        jit: MlirExecutionEngine,
        name: MlirStringRef,
        sym: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Dump as an object in `fileName`."]
    pub fn mlirExecutionEngineDumpToObjectFile(jit: MlirExecutionEngine, fileName: MlirStringRef);
}
#[doc = " An opaque reference to a diagnostic, always owned by the diagnostics engine"]
#[doc = " (context). Must not be stored outside of the diagnostic handler."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirDiagnostic {
    pub ptr: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirDiagnostic() {
    assert_eq!(
        ::std::mem::size_of::<MlirDiagnostic>(),
        8usize,
        concat!("Size of: ", stringify!(MlirDiagnostic))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirDiagnostic>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirDiagnostic))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirDiagnostic>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirDiagnostic),
            "::",
            stringify!(ptr)
        )
    );
}
pub const MlirDiagnosticSeverity_MlirDiagnosticError: MlirDiagnosticSeverity = 0;
pub const MlirDiagnosticSeverity_MlirDiagnosticWarning: MlirDiagnosticSeverity = 1;
pub const MlirDiagnosticSeverity_MlirDiagnosticNote: MlirDiagnosticSeverity = 2;
pub const MlirDiagnosticSeverity_MlirDiagnosticRemark: MlirDiagnosticSeverity = 3;
#[doc = " Severity of a diagnostic."]
pub type MlirDiagnosticSeverity = ::std::os::raw::c_uint;
#[doc = " Opaque identifier of a diagnostic handler, useful to detach a handler."]
pub type MlirDiagnosticHandlerID = u64;
#[doc = " Diagnostic handler type. Accepts a reference to a diagnostic, which is only"]
#[doc = " guaranteed to be live during the call. The handler is passed the `userData`"]
#[doc = " that was provided when the handler was attached to a context. If the handler"]
#[doc = " processed the diagnostic completely, it is expected to return success."]
#[doc = " Otherwise, it is expected to return failure to indicate that other handlers"]
#[doc = " should attempt to process the diagnostic."]
pub type MlirDiagnosticHandler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: MlirDiagnostic,
        userData: *mut ::std::os::raw::c_void,
    ) -> MlirLogicalResult,
>;
extern "C" {
    #[doc = " Prints a diagnostic using the provided callback."]
    pub fn mlirDiagnosticPrint(
        diagnostic: MlirDiagnostic,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns the location at which the diagnostic is reported."]
    pub fn mlirDiagnosticGetLocation(diagnostic: MlirDiagnostic) -> MlirLocation;
}
extern "C" {
    #[doc = " Returns the severity of the diagnostic."]
    pub fn mlirDiagnosticGetSeverity(diagnostic: MlirDiagnostic) -> MlirDiagnosticSeverity;
}
extern "C" {
    #[doc = " Returns the number of notes attached to the diagnostic."]
    pub fn mlirDiagnosticGetNumNotes(diagnostic: MlirDiagnostic) -> isize;
}
extern "C" {
    #[doc = " Returns `pos`-th note attached to the diagnostic. Expects `pos` to be a"]
    #[doc = " valid zero-based index into the list of notes."]
    pub fn mlirDiagnosticGetNote(diagnostic: MlirDiagnostic, pos: isize) -> MlirDiagnostic;
}
extern "C" {
    #[doc = " Attaches the diagnostic handler to the context. Handlers are invoked in the"]
    #[doc = " reverse order of attachment until one of them processes the diagnostic"]
    #[doc = " completely. When a handler is invoked it is passed the `userData` that was"]
    #[doc = " provided when it was attached. If non-NULL, `deleteUserData` is called once"]
    #[doc = " the system no longer needs to call the handler (for instance after the"]
    #[doc = " handler is detached or the context is destroyed). Returns an identifier that"]
    #[doc = " can be used to detach the handler."]
    pub fn mlirContextAttachDiagnosticHandler(
        context: MlirContext,
        handler: MlirDiagnosticHandler,
        userData: *mut ::std::os::raw::c_void,
        deleteUserData: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> MlirDiagnosticHandlerID;
}
extern "C" {
    #[doc = " Detaches an attached diagnostic handler from the context given its"]
    #[doc = " identifier."]
    pub fn mlirContextDetachDiagnosticHandler(context: MlirContext, id: MlirDiagnosticHandlerID);
}
extern "C" {
    #[doc = " Emits an error at the given location through the diagnostics engine. Used"]
    #[doc = " for testing purposes."]
    pub fn mlirEmitError(location: MlirLocation, message: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn mlirRegisterConversionPasses();
}
extern "C" {
    pub fn mlirCreateConversionConvertAffineForToGPU() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertAffineForToGPU();
}
extern "C" {
    pub fn mlirCreateConversionConvertAffineToStandard() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertAffineToStandard();
}
extern "C" {
    pub fn mlirCreateConversionConvertArmNeon2dToIntr() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertArmNeon2dToIntr();
}
extern "C" {
    pub fn mlirCreateConversionConvertAsyncToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertAsyncToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertComplexToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertComplexToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertComplexToStandard() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertComplexToStandard();
}
extern "C" {
    pub fn mlirCreateConversionConvertGPUToSPIRV() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertGPUToSPIRV();
}
extern "C" {
    pub fn mlirCreateConversionConvertGpuLaunchFuncToVulkanLaunchFunc() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertGpuLaunchFuncToVulkanLaunchFunc();
}
extern "C" {
    pub fn mlirCreateConversionConvertGpuOpsToNVVMOps() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertGpuOpsToNVVMOps();
}
extern "C" {
    pub fn mlirCreateConversionConvertGpuOpsToROCDLOps() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertGpuOpsToROCDLOps();
}
extern "C" {
    pub fn mlirCreateConversionConvertLinalgToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertLinalgToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertLinalgToSPIRV() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertLinalgToSPIRV();
}
extern "C" {
    pub fn mlirCreateConversionConvertLinalgToStandard() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertLinalgToStandard();
}
extern "C" {
    pub fn mlirCreateConversionConvertMathToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertMathToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertMathToLibm() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertMathToLibm();
}
extern "C" {
    pub fn mlirCreateConversionConvertMemRefToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertMemRefToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertOpenACCToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertOpenACCToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertOpenACCToSCF() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertOpenACCToSCF();
}
extern "C" {
    pub fn mlirCreateConversionConvertOpenMPToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertOpenMPToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertPDLToPDLInterp() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertPDLToPDLInterp();
}
extern "C" {
    pub fn mlirCreateConversionConvertParallelLoopToGpu() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertParallelLoopToGpu();
}
extern "C" {
    pub fn mlirCreateConversionConvertSCFToOpenMP() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertSCFToOpenMP();
}
extern "C" {
    pub fn mlirCreateConversionConvertSPIRVToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertSPIRVToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertShapeConstraints() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertShapeConstraints();
}
extern "C" {
    pub fn mlirCreateConversionConvertShapeToStandard() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertShapeToStandard();
}
extern "C" {
    pub fn mlirCreateConversionConvertStandardToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertStandardToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertStandardToSPIRV() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertStandardToSPIRV();
}
extern "C" {
    pub fn mlirCreateConversionConvertVectorToGPU() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertVectorToGPU();
}
extern "C" {
    pub fn mlirCreateConversionConvertVectorToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertVectorToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionConvertVectorToROCDL() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertVectorToROCDL();
}
extern "C" {
    pub fn mlirCreateConversionConvertVectorToSCF() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertVectorToSCF();
}
extern "C" {
    pub fn mlirCreateConversionConvertVectorToSPIRV() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertVectorToSPIRV();
}
extern "C" {
    pub fn mlirCreateConversionConvertVulkanLaunchFuncToVulkanCalls() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionConvertVulkanLaunchFuncToVulkanCalls();
}
extern "C" {
    pub fn mlirCreateConversionGpuToLLVMConversionPass() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionGpuToLLVMConversionPass();
}
extern "C" {
    pub fn mlirCreateConversionLowerHostCodeToLLVM() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionLowerHostCodeToLLVM();
}
extern "C" {
    pub fn mlirCreateConversionSCFToSPIRV() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionSCFToSPIRV();
}
extern "C" {
    pub fn mlirCreateConversionSCFToStandard() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionSCFToStandard();
}
extern "C" {
    pub fn mlirCreateConversionTosaToLinalgOnTensors() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionTosaToLinalgOnTensors();
}
extern "C" {
    pub fn mlirCreateConversionTosaToSCF() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionTosaToSCF();
}
extern "C" {
    pub fn mlirCreateConversionTosaToStandard() -> MlirPass;
}
extern "C" {
    pub fn mlirRegisterConversionTosaToStandard();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlirAffineMap {
    pub ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_MlirAffineMap() {
    assert_eq!(
        ::std::mem::size_of::<MlirAffineMap>(),
        8usize,
        concat!("Size of: ", stringify!(MlirAffineMap))
    );
    assert_eq!(
        ::std::mem::align_of::<MlirAffineMap>(),
        8usize,
        concat!("Alignment of ", stringify!(MlirAffineMap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MlirAffineMap>())).ptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MlirAffineMap),
            "::",
            stringify!(ptr)
        )
    );
}
extern "C" {
    #[doc = " Gets the context that the given affine map was created with"]
    pub fn mlirAffineMapGetContext(affineMap: MlirAffineMap) -> MlirContext;
}
extern "C" {
    #[doc = " Checks if two affine maps are equal."]
    pub fn mlirAffineMapEqual(a1: MlirAffineMap, a2: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Prints an affine map by sending chunks of the string representation and"]
    #[doc = " forwarding `userData to `callback`. Note that the callback may be called"]
    #[doc = " several times with consecutive chunks of the string."]
    pub fn mlirAffineMapPrint(
        affineMap: MlirAffineMap,
        callback: MlirStringCallback,
        userData: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Prints the affine map to the standard error stream."]
    pub fn mlirAffineMapDump(affineMap: MlirAffineMap);
}
extern "C" {
    #[doc = " Creates a zero result affine map with no dimensions or symbols in the"]
    #[doc = " context. The affine map is owned by the context."]
    pub fn mlirAffineMapEmptyGet(ctx: MlirContext) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Creates a zero result affine map of the given dimensions and symbols in the"]
    #[doc = " context. The affine map is owned by the context."]
    pub fn mlirAffineMapZeroResultGet(
        ctx: MlirContext,
        dimCount: isize,
        symbolCount: isize,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Creates an affine map with results defined by the given list of affine"]
    #[doc = " expressions. The map resulting map also has the requested number of input"]
    #[doc = " dimensions and symbols, regardless of them being used in the results."]
    pub fn mlirAffineMapGet(
        ctx: MlirContext,
        dimCount: isize,
        symbolCount: isize,
        nAffineExprs: isize,
        affineExprs: *mut MlirAffineExpr,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Creates a single constant result affine map in the context. The affine map"]
    #[doc = " is owned by the context."]
    pub fn mlirAffineMapConstantGet(ctx: MlirContext, val: i64) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Creates an affine map with 'numDims' identity in the context. The affine map"]
    #[doc = " is owned by the context."]
    pub fn mlirAffineMapMultiDimIdentityGet(ctx: MlirContext, numDims: isize) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Creates an identity affine map on the most minor dimensions in the context."]
    #[doc = " The affine map is owned by the context. The function asserts that the number"]
    #[doc = " of dimensions is greater or equal to the number of results."]
    pub fn mlirAffineMapMinorIdentityGet(
        ctx: MlirContext,
        dims: isize,
        results: isize,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Creates an affine map with a permutation expression and its size in the"]
    #[doc = " context. The permutation expression is a non-empty vector of integers."]
    #[doc = " The elements of the permutation vector must be continuous from 0 and cannot"]
    #[doc = " be repeated (i.e. `[1,2,0]` is a valid permutation. `[2,0]` or `[1,1,2]` is"]
    #[doc = " an invalid invalid permutation.) The affine map is owned by the context."]
    pub fn mlirAffineMapPermutationGet(
        ctx: MlirContext,
        size: isize,
        permutation: *mut ::std::os::raw::c_uint,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Checks whether the given affine map is an identity affine map. The function"]
    #[doc = " asserts that the number of dimensions is greater or equal to the number of"]
    #[doc = " results."]
    pub fn mlirAffineMapIsIdentity(affineMap: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine map is a minor identity affine map."]
    pub fn mlirAffineMapIsMinorIdentity(affineMap: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine map is an empty affine map."]
    pub fn mlirAffineMapIsEmpty(affineMap: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine map is a single result constant affine"]
    #[doc = " map."]
    pub fn mlirAffineMapIsSingleConstant(affineMap: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Returns the constant result of the given affine map. The function asserts"]
    #[doc = " that the map has a single constant result."]
    pub fn mlirAffineMapGetSingleConstantResult(affineMap: MlirAffineMap) -> i64;
}
extern "C" {
    #[doc = " Returns the number of dimensions of the given affine map."]
    pub fn mlirAffineMapGetNumDims(affineMap: MlirAffineMap) -> isize;
}
extern "C" {
    #[doc = " Returns the number of symbols of the given affine map."]
    pub fn mlirAffineMapGetNumSymbols(affineMap: MlirAffineMap) -> isize;
}
extern "C" {
    #[doc = " Returns the number of results of the given affine map."]
    pub fn mlirAffineMapGetNumResults(affineMap: MlirAffineMap) -> isize;
}
extern "C" {
    #[doc = " Returns the result at the given position."]
    pub fn mlirAffineMapGetResult(affineMap: MlirAffineMap, pos: isize) -> MlirAffineExpr;
}
extern "C" {
    #[doc = " Returns the number of inputs (dimensions + symbols) of the given affine"]
    #[doc = " map."]
    pub fn mlirAffineMapGetNumInputs(affineMap: MlirAffineMap) -> isize;
}
extern "C" {
    #[doc = " Checks whether the given affine map represents a subset of a symbol-less"]
    #[doc = " permutation map."]
    pub fn mlirAffineMapIsProjectedPermutation(affineMap: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given affine map represents a symbol-less permutation"]
    #[doc = " map."]
    pub fn mlirAffineMapIsPermutation(affineMap: MlirAffineMap) -> bool;
}
extern "C" {
    #[doc = " Returns the affine map consisting of the `resultPos` subset."]
    pub fn mlirAffineMapGetSubMap(
        affineMap: MlirAffineMap,
        size: isize,
        resultPos: *mut isize,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Returns the affine map consisting of the most major `numResults` results."]
    #[doc = " Returns the null AffineMap if the `numResults` is equal to zero."]
    #[doc = " Returns the `affineMap` if `numResults` is greater or equals to number of"]
    #[doc = " results of the given affine map."]
    pub fn mlirAffineMapGetMajorSubMap(
        affineMap: MlirAffineMap,
        numResults: isize,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Returns the affine map consisting of the most minor `numResults` results."]
    #[doc = " Returns the null AffineMap if the `numResults` is equal to zero."]
    #[doc = " Returns the `affineMap` if `numResults` is greater or equals to number of"]
    #[doc = " results of the given affine map."]
    pub fn mlirAffineMapGetMinorSubMap(
        affineMap: MlirAffineMap,
        numResults: isize,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Apply AffineExpr::replace(`map`) to each of the results and return a new"]
    #[doc = " new AffineMap with the new results and the specified number of dims and"]
    #[doc = " symbols."]
    pub fn mlirAffineMapReplace(
        affineMap: MlirAffineMap,
        expression: MlirAffineExpr,
        replacement: MlirAffineExpr,
        numResultDims: isize,
        numResultSyms: isize,
    ) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Returns the simplified affine map resulting from dropping the symbols that"]
    #[doc = " do not appear in any of the individual maps in `affineMaps`."]
    #[doc = " Asserts that all maps in `affineMaps` are normalized to the same number of"]
    #[doc = " dims and symbols."]
    #[doc = " Takes a callback `populateResult` to fill the `res` container with value"]
    #[doc = " `m` at entry `idx`. This allows returning without worrying about ownership"]
    #[doc = " considerations."]
    pub fn mlirAffineMapCompressUnusedSymbols(
        affineMaps: *mut MlirAffineMap,
        size: isize,
        result: *mut ::std::os::raw::c_void,
        populateResult: ::std::option::Option<
            unsafe extern "C" fn(res: *mut ::std::os::raw::c_void, idx: isize, m: MlirAffineMap),
        >,
    );
}
extern "C" {
    #[doc = " Checks whether the given type is an integer type."]
    pub fn mlirTypeIsAInteger(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a signless integer type of the given bitwidth in the context. The"]
    #[doc = " type is owned by the context."]
    pub fn mlirIntegerTypeGet(ctx: MlirContext, bitwidth: ::std::os::raw::c_uint) -> MlirType;
}
extern "C" {
    #[doc = " Creates a signed integer type of the given bitwidth in the context. The type"]
    #[doc = " is owned by the context."]
    pub fn mlirIntegerTypeSignedGet(ctx: MlirContext, bitwidth: ::std::os::raw::c_uint)
        -> MlirType;
}
extern "C" {
    #[doc = " Creates an unsigned integer type of the given bitwidth in the context. The"]
    #[doc = " type is owned by the context."]
    pub fn mlirIntegerTypeUnsignedGet(
        ctx: MlirContext,
        bitwidth: ::std::os::raw::c_uint,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Returns the bitwidth of an integer type."]
    pub fn mlirIntegerTypeGetWidth(type_: MlirType) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Checks whether the given integer type is signless."]
    pub fn mlirIntegerTypeIsSignless(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given integer type is signed."]
    pub fn mlirIntegerTypeIsSigned(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given integer type is unsigned."]
    pub fn mlirIntegerTypeIsUnsigned(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given type is an index type."]
    pub fn mlirTypeIsAIndex(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates an index type in the given context. The type is owned by the"]
    #[doc = " context."]
    pub fn mlirIndexTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a bf16 type."]
    pub fn mlirTypeIsABF16(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a bf16 type in the given context. The type is owned by the"]
    #[doc = " context."]
    pub fn mlirBF16TypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is an f16 type."]
    pub fn mlirTypeIsAF16(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates an f16 type in the given context. The type is owned by the"]
    #[doc = " context."]
    pub fn mlirF16TypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is an f32 type."]
    pub fn mlirTypeIsAF32(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates an f32 type in the given context. The type is owned by the"]
    #[doc = " context."]
    pub fn mlirF32TypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is an f64 type."]
    pub fn mlirTypeIsAF64(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a f64 type in the given context. The type is owned by the"]
    #[doc = " context."]
    pub fn mlirF64TypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a None type."]
    pub fn mlirTypeIsANone(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a None type in the given context. The type is owned by the"]
    #[doc = " context."]
    pub fn mlirNoneTypeGet(ctx: MlirContext) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a Complex type."]
    pub fn mlirTypeIsAComplex(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a complex type with the given element type in the same context as"]
    #[doc = " the element type. The type is owned by the context."]
    pub fn mlirComplexTypeGet(elementType: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Returns the element type of the given complex type."]
    pub fn mlirComplexTypeGetElementType(type_: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a Shaped type."]
    pub fn mlirTypeIsAShaped(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Returns the element type of the shaped type."]
    pub fn mlirShapedTypeGetElementType(type_: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given shaped type is ranked."]
    pub fn mlirShapedTypeHasRank(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Returns the rank of the given ranked shaped type."]
    pub fn mlirShapedTypeGetRank(type_: MlirType) -> i64;
}
extern "C" {
    #[doc = " Checks whether the given shaped type has a static shape."]
    pub fn mlirShapedTypeHasStaticShape(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks wither the dim-th dimension of the given shaped type is dynamic."]
    pub fn mlirShapedTypeIsDynamicDim(type_: MlirType, dim: isize) -> bool;
}
extern "C" {
    #[doc = " Returns the dim-th dimension of the given ranked shaped type."]
    pub fn mlirShapedTypeGetDimSize(type_: MlirType, dim: isize) -> i64;
}
extern "C" {
    #[doc = " Checks whether the given value is used as a placeholder for dynamic sizes"]
    #[doc = " in shaped types."]
    pub fn mlirShapedTypeIsDynamicSize(size: i64) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given value is used as a placeholder for dynamic strides"]
    #[doc = " and offsets in shaped types."]
    pub fn mlirShapedTypeIsDynamicStrideOrOffset(val: i64) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given type is a Vector type."]
    pub fn mlirTypeIsAVector(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a vector type of the shape identified by its rank and dimensions,"]
    #[doc = " with the given element type in the same context as the element type. The"]
    #[doc = " type is owned by the context."]
    pub fn mlirVectorTypeGet(rank: isize, shape: *const i64, elementType: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Same as \"mlirVectorTypeGet\" but returns a nullptr wrapping MlirType on"]
    #[doc = " illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirVectorTypeGetChecked(
        loc: MlirLocation,
        rank: isize,
        shape: *const i64,
        elementType: MlirType,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a Tensor type."]
    pub fn mlirTypeIsATensor(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given type is a ranked tensor type."]
    pub fn mlirTypeIsARankedTensor(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given type is an unranked tensor type."]
    pub fn mlirTypeIsAUnrankedTensor(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a tensor type of a fixed rank with the given shape, element type,"]
    #[doc = " and optional encoding in the same context as the element type. The type is"]
    #[doc = " owned by the context. Tensor types without any specific encoding field"]
    #[doc = " should assign mlirAttributeGetNull() to this parameter."]
    pub fn mlirRankedTensorTypeGet(
        rank: isize,
        shape: *const i64,
        elementType: MlirType,
        encoding: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Same as \"mlirRankedTensorTypeGet\" but returns a nullptr wrapping MlirType on"]
    #[doc = " illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirRankedTensorTypeGetChecked(
        loc: MlirLocation,
        rank: isize,
        shape: *const i64,
        elementType: MlirType,
        encoding: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Gets the 'encoding' attribute from the ranked tensor type, returning a null"]
    #[doc = " attribute if none."]
    pub fn mlirRankedTensorTypeGetEncoding(type_: MlirType) -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates an unranked tensor type with the given element type in the same"]
    #[doc = " context as the element type. The type is owned by the context."]
    pub fn mlirUnrankedTensorTypeGet(elementType: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Same as \"mlirUnrankedTensorTypeGet\" but returns a nullptr wrapping MlirType"]
    #[doc = " on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirUnrankedTensorTypeGetChecked(loc: MlirLocation, elementType: MlirType) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a MemRef type."]
    pub fn mlirTypeIsAMemRef(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given type is an UnrankedMemRef type."]
    pub fn mlirTypeIsAUnrankedMemRef(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a MemRef type with the given rank and shape, a potentially empty"]
    #[doc = " list of affine layout maps, the given memory space and element type, in the"]
    #[doc = " same context as element type. The type is owned by the context."]
    pub fn mlirMemRefTypeGet(
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        numMaps: isize,
        affineMaps: *const MlirAffineMap,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Same as \"mlirMemRefTypeGet\" but returns a nullptr-wrapping MlirType o"]
    #[doc = " illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirMemRefTypeGetChecked(
        loc: MlirLocation,
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        numMaps: isize,
        affineMaps: *const MlirAffineMap,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Creates a MemRef type with the given rank, shape, memory space and element"]
    #[doc = " type in the same context as the element type. The type has no affine maps,"]
    #[doc = " i.e. represents a default row-major contiguous memref. The type is owned by"]
    #[doc = " the context."]
    pub fn mlirMemRefTypeContiguousGet(
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Same as \"mlirMemRefTypeContiguousGet\" but returns a nullptr wrapping"]
    #[doc = " MlirType on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirMemRefTypeContiguousGetChecked(
        loc: MlirLocation,
        elementType: MlirType,
        rank: isize,
        shape: *const i64,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Creates an Unranked MemRef type with the given element type and in the given"]
    #[doc = " memory space. The type is owned by the context of element type."]
    pub fn mlirUnrankedMemRefTypeGet(elementType: MlirType, memorySpace: MlirAttribute)
        -> MlirType;
}
extern "C" {
    #[doc = " Same as \"mlirUnrankedMemRefTypeGet\" but returns a nullptr wrapping"]
    #[doc = " MlirType on illegal arguments, emitting appropriate diagnostics."]
    pub fn mlirUnrankedMemRefTypeGetChecked(
        loc: MlirLocation,
        elementType: MlirType,
        memorySpace: MlirAttribute,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Returns the number of affine layout maps in the given MemRef type."]
    pub fn mlirMemRefTypeGetNumAffineMaps(type_: MlirType) -> isize;
}
extern "C" {
    #[doc = " Returns the pos-th affine map of the given MemRef type."]
    pub fn mlirMemRefTypeGetAffineMap(type_: MlirType, pos: isize) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Returns the memory space of the given MemRef type."]
    pub fn mlirMemRefTypeGetMemorySpace(type_: MlirType) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the memory spcae of the given Unranked MemRef type."]
    pub fn mlirUnrankedMemrefGetMemorySpace(type_: MlirType) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given type is a tuple type."]
    pub fn mlirTypeIsATuple(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a tuple type that consists of the given list of elemental types. The"]
    #[doc = " type is owned by the context."]
    pub fn mlirTupleTypeGet(
        ctx: MlirContext,
        numElements: isize,
        elements: *const MlirType,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Returns the number of types contained in a tuple."]
    pub fn mlirTupleTypeGetNumTypes(type_: MlirType) -> isize;
}
extern "C" {
    #[doc = " Returns the pos-th type in the tuple type."]
    pub fn mlirTupleTypeGetType(type_: MlirType, pos: isize) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given type is a function type."]
    pub fn mlirTypeIsAFunction(type_: MlirType) -> bool;
}
extern "C" {
    #[doc = " Creates a function type, mapping a list of input types to result types."]
    pub fn mlirFunctionTypeGet(
        ctx: MlirContext,
        numInputs: isize,
        inputs: *const MlirType,
        numResults: isize,
        results: *const MlirType,
    ) -> MlirType;
}
extern "C" {
    #[doc = " Returns the number of input types."]
    pub fn mlirFunctionTypeGetNumInputs(type_: MlirType) -> isize;
}
extern "C" {
    #[doc = " Returns the number of result types."]
    pub fn mlirFunctionTypeGetNumResults(type_: MlirType) -> isize;
}
extern "C" {
    #[doc = " Returns the pos-th input type."]
    pub fn mlirFunctionTypeGetInput(type_: MlirType, pos: isize) -> MlirType;
}
extern "C" {
    #[doc = " Returns the pos-th result type."]
    pub fn mlirFunctionTypeGetResult(type_: MlirType, pos: isize) -> MlirType;
}
extern "C" {
    #[doc = " Returns an empty attribute."]
    pub fn mlirAttributeGetNull() -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an affine map attribute."]
    pub fn mlirAttributeIsAAffineMap(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates an affine map attribute wrapping the given map. The attribute"]
    #[doc = " belongs to the same context as the affine map."]
    pub fn mlirAffineMapAttrGet(map: MlirAffineMap) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the affine map wrapped in the given affine map attribute."]
    pub fn mlirAffineMapAttrGetValue(attr: MlirAttribute) -> MlirAffineMap;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an array attribute."]
    pub fn mlirAttributeIsAArray(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates an array element containing the given list of elements in the given"]
    #[doc = " context."]
    pub fn mlirArrayAttrGet(
        ctx: MlirContext,
        numElements: isize,
        elements: *const MlirAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the number of elements stored in the given array attribute."]
    pub fn mlirArrayAttrGetNumElements(attr: MlirAttribute) -> isize;
}
extern "C" {
    #[doc = " Returns pos-th element stored in the given array attribute."]
    pub fn mlirArrayAttrGetElement(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a dictionary attribute."]
    pub fn mlirAttributeIsADictionary(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a dictionary attribute containing the given list of elements in the"]
    #[doc = " provided context."]
    pub fn mlirDictionaryAttrGet(
        ctx: MlirContext,
        numElements: isize,
        elements: *const MlirNamedAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the number of attributes contained in a dictionary attribute."]
    pub fn mlirDictionaryAttrGetNumElements(attr: MlirAttribute) -> isize;
}
extern "C" {
    #[doc = " Returns pos-th element of the given dictionary attribute."]
    pub fn mlirDictionaryAttrGetElement(attr: MlirAttribute, pos: isize) -> MlirNamedAttribute;
}
extern "C" {
    #[doc = " Returns the dictionary attribute element with the given name or NULL if the"]
    #[doc = " given name does not exist in the dictionary."]
    pub fn mlirDictionaryAttrGetElementByName(
        attr: MlirAttribute,
        name: MlirStringRef,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a floating point attribute."]
    pub fn mlirAttributeIsAFloat(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a floating point attribute in the given context with the given"]
    #[doc = " double value and double-precision FP semantics."]
    pub fn mlirFloatAttrDoubleGet(ctx: MlirContext, type_: MlirType, value: f64) -> MlirAttribute;
}
extern "C" {
    #[doc = " Same as \"mlirFloatAttrDoubleGet\", but if the type is not valid for a"]
    #[doc = " construction of a FloatAttr, returns a null MlirAttribute."]
    pub fn mlirFloatAttrDoubleGetChecked(
        loc: MlirLocation,
        type_: MlirType,
        value: f64,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the value stored in the given floating point attribute, interpreting"]
    #[doc = " the value as double."]
    pub fn mlirFloatAttrGetValueDouble(attr: MlirAttribute) -> f64;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an integer attribute."]
    pub fn mlirAttributeIsAInteger(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates an integer attribute of the given type with the given integer"]
    #[doc = " value."]
    pub fn mlirIntegerAttrGet(type_: MlirType, value: i64) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the value stored in the given integer attribute, assuming the value"]
    #[doc = " fits into a 64-bit integer."]
    pub fn mlirIntegerAttrGetValueInt(attr: MlirAttribute) -> i64;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a bool attribute."]
    pub fn mlirAttributeIsABool(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a bool attribute in the given context with the given value."]
    pub fn mlirBoolAttrGet(ctx: MlirContext, value: ::std::os::raw::c_int) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the value stored in the given bool attribute."]
    pub fn mlirBoolAttrGetValue(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an integer set attribute."]
    pub fn mlirAttributeIsAIntegerSet(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an opaque attribute."]
    pub fn mlirAttributeIsAOpaque(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates an opaque attribute in the given context associated with the dialect"]
    #[doc = " identified by its namespace. The attribute contains opaque byte data of the"]
    #[doc = " specified length (data need not be null-terminated)."]
    pub fn mlirOpaqueAttrGet(
        ctx: MlirContext,
        dialectNamespace: MlirStringRef,
        dataLength: isize,
        data: *const ::std::os::raw::c_char,
        type_: MlirType,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the namespace of the dialect with which the given opaque attribute"]
    #[doc = " is associated. The namespace string is owned by the context."]
    pub fn mlirOpaqueAttrGetDialectNamespace(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the raw data as a string reference. The data remains live as long as"]
    #[doc = " the context in which the attribute lives."]
    pub fn mlirOpaqueAttrGetData(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a string attribute."]
    pub fn mlirAttributeIsAString(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a string attribute in the given context containing the given string."]
    pub fn mlirStringAttrGet(ctx: MlirContext, str_: MlirStringRef) -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates a string attribute in the given context containing the given string."]
    #[doc = " Additionally, the attribute has the given type."]
    pub fn mlirStringAttrTypedGet(type_: MlirType, str_: MlirStringRef) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the attribute values as a string reference. The data remains live as"]
    #[doc = " long as the context in which the attribute lives."]
    pub fn mlirStringAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a symbol reference attribute."]
    pub fn mlirAttributeIsASymbolRef(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a symbol reference attribute in the given context referencing a"]
    #[doc = " symbol identified by the given string inside a list of nested references."]
    #[doc = " Each of the references in the list must not be nested."]
    pub fn mlirSymbolRefAttrGet(
        ctx: MlirContext,
        symbol: MlirStringRef,
        numReferences: isize,
        references: *const MlirAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the string reference to the root referenced symbol. The data remains"]
    #[doc = " live as long as the context in which the attribute lives."]
    pub fn mlirSymbolRefAttrGetRootReference(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the string reference to the leaf referenced symbol. The data remains"]
    #[doc = " live as long as the context in which the attribute lives."]
    pub fn mlirSymbolRefAttrGetLeafReference(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the number of references nested in the given symbol reference"]
    #[doc = " attribute."]
    pub fn mlirSymbolRefAttrGetNumNestedReferences(attr: MlirAttribute) -> isize;
}
extern "C" {
    #[doc = " Returns pos-th reference nested in the given symbol reference attribute."]
    pub fn mlirSymbolRefAttrGetNestedReference(attr: MlirAttribute, pos: isize) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a flat symbol reference attribute."]
    pub fn mlirAttributeIsAFlatSymbolRef(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a flat symbol reference attribute in the given context referencing a"]
    #[doc = " symbol identified by the given string."]
    pub fn mlirFlatSymbolRefAttrGet(ctx: MlirContext, symbol: MlirStringRef) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the referenced symbol as a string reference. The data remains live"]
    #[doc = " as long as the context in which the attribute lives."]
    pub fn mlirFlatSymbolRefAttrGetValue(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a type attribute."]
    pub fn mlirAttributeIsAType(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a type attribute wrapping the given type in the same context as the"]
    #[doc = " type."]
    pub fn mlirTypeAttrGet(type_: MlirType) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the type stored in the given type attribute."]
    pub fn mlirTypeAttrGetValue(attr: MlirAttribute) -> MlirType;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a unit attribute."]
    pub fn mlirAttributeIsAUnit(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a unit attribute in the given context."]
    pub fn mlirUnitAttrGet(ctx: MlirContext) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an elements attribute."]
    pub fn mlirAttributeIsAElements(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Returns the element at the given rank-dimensional index."]
    pub fn mlirElementsAttrGetValue(
        attr: MlirAttribute,
        rank: isize,
        idxs: *mut u64,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given rank-dimensional index is valid in the given"]
    #[doc = " elements attribute."]
    pub fn mlirElementsAttrIsValidIndex(attr: MlirAttribute, rank: isize, idxs: *mut u64) -> bool;
}
extern "C" {
    #[doc = " Gets the total number of elements in the given elements attribute. In order"]
    #[doc = " to iterate over the attribute, obtain its type, which must be a statically"]
    #[doc = " shaped type and use its sizes to build a multi-dimensional index."]
    pub fn mlirElementsAttrGetNumElements(attr: MlirAttribute) -> i64;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a dense elements attribute."]
    pub fn mlirAttributeIsADenseElements(attr: MlirAttribute) -> bool;
}
extern "C" {
    pub fn mlirAttributeIsADenseIntElements(attr: MlirAttribute) -> bool;
}
extern "C" {
    pub fn mlirAttributeIsADenseFPElements(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a dense elements attribute with the given Shaped type and elements"]
    #[doc = " in the same context as the type."]
    pub fn mlirDenseElementsAttrGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const MlirAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates a dense elements attribute with the given Shaped type containing a"]
    #[doc = " single replicated element (splat)."]
    pub fn mlirDenseElementsAttrSplatGet(
        shapedType: MlirType,
        element: MlirAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrBoolSplatGet(shapedType: MlirType, element: bool) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrUInt8SplatGet(shapedType: MlirType, element: u8) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrInt8SplatGet(shapedType: MlirType, element: i8) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrUInt32SplatGet(shapedType: MlirType, element: u32)
        -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrInt32SplatGet(shapedType: MlirType, element: i32) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrUInt64SplatGet(shapedType: MlirType, element: u64)
        -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrInt64SplatGet(shapedType: MlirType, element: i64) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrFloatSplatGet(shapedType: MlirType, element: f32) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrDoubleSplatGet(shapedType: MlirType, element: f64)
        -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates a dense elements attribute with the given shaped type from elements"]
    #[doc = " of a specific type. Expects the element type of the shaped type to match the"]
    #[doc = " data element type."]
    pub fn mlirDenseElementsAttrBoolGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const ::std::os::raw::c_int,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrUInt8Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u8,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrInt8Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const i8,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrUInt32Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u32,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrInt32Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const i32,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrUInt64Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const u64,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrInt64Get(
        shapedType: MlirType,
        numElements: isize,
        elements: *const i64,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrFloatGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const f32,
    ) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrDoubleGet(
        shapedType: MlirType,
        numElements: isize,
        elements: *const f64,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates a dense elements attribute with the given shaped type from string"]
    #[doc = " elements."]
    pub fn mlirDenseElementsAttrStringGet(
        shapedType: MlirType,
        numElements: isize,
        strs: *mut MlirStringRef,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Creates a dense elements attribute that has the same data as the given dense"]
    #[doc = " elements attribute and a different shaped type. The new type must have the"]
    #[doc = " same total number of elements."]
    pub fn mlirDenseElementsAttrReshapeGet(
        attr: MlirAttribute,
        shapedType: MlirType,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Checks whether the given dense elements attribute contains a single"]
    #[doc = " replicated value (splat)."]
    pub fn mlirDenseElementsAttrIsSplat(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Returns the single replicated value (splat) of a specific type contained by"]
    #[doc = " the given dense elements attribute."]
    pub fn mlirDenseElementsAttrGetSplatValue(attr: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetBoolSplatValue(attr: MlirAttribute) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetInt8SplatValue(attr: MlirAttribute) -> i8;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetUInt8SplatValue(attr: MlirAttribute) -> u8;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetInt32SplatValue(attr: MlirAttribute) -> i32;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetUInt32SplatValue(attr: MlirAttribute) -> u32;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetInt64SplatValue(attr: MlirAttribute) -> i64;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetUInt64SplatValue(attr: MlirAttribute) -> u64;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetFloatSplatValue(attr: MlirAttribute) -> f32;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetDoubleSplatValue(attr: MlirAttribute) -> f64;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetStringSplatValue(attr: MlirAttribute) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the pos-th value (flat contiguous indexing) of a specific type"]
    #[doc = " contained by the given dense elements attribute."]
    pub fn mlirDenseElementsAttrGetBoolValue(attr: MlirAttribute, pos: isize) -> bool;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetInt8Value(attr: MlirAttribute, pos: isize) -> i8;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetUInt8Value(attr: MlirAttribute, pos: isize) -> u8;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetInt32Value(attr: MlirAttribute, pos: isize) -> i32;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetUInt32Value(attr: MlirAttribute, pos: isize) -> u32;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetInt64Value(attr: MlirAttribute, pos: isize) -> i64;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetUInt64Value(attr: MlirAttribute, pos: isize) -> u64;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetFloatValue(attr: MlirAttribute, pos: isize) -> f32;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetDoubleValue(attr: MlirAttribute, pos: isize) -> f64;
}
extern "C" {
    pub fn mlirDenseElementsAttrGetStringValue(attr: MlirAttribute, pos: isize) -> MlirStringRef;
}
extern "C" {
    #[doc = " Returns the raw data of the given dense elements attribute."]
    pub fn mlirDenseElementsAttrGetRawData(attr: MlirAttribute) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Checks whether the given attribute is an opaque elements attribute."]
    pub fn mlirAttributeIsAOpaqueElements(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Checks whether the given attribute is a sparse elements attribute."]
    pub fn mlirAttributeIsASparseElements(attr: MlirAttribute) -> bool;
}
extern "C" {
    #[doc = " Creates a sparse elements attribute of the given shape from a list of"]
    #[doc = " indices and a list of associated values. Both lists are expected to be dense"]
    #[doc = " elements attributes with the same number of elements. The list of indices is"]
    #[doc = " expected to contain 64-bit integers. The attribute is created in the same"]
    #[doc = " context as the type."]
    pub fn mlirSparseElementsAttribute(
        shapedType: MlirType,
        denseIndices: MlirAttribute,
        denseValues: MlirAttribute,
    ) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the dense elements attribute containing 64-bit integer indices of"]
    #[doc = " non-null elements in the given sparse elements attribute."]
    pub fn mlirSparseElementsAttrGetIndices(attr: MlirAttribute) -> MlirAttribute;
}
extern "C" {
    #[doc = " Returns the dense elements attribute containing the non-null elements in the"]
    #[doc = " given sparse elements attribute."]
    pub fn mlirSparseElementsAttrGetValues(attr: MlirAttribute) -> MlirAttribute;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
